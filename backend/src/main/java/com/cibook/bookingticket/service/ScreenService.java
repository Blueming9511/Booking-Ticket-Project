package com.cibook.bookingticket.service;

import com.cibook.bookingticket.dto.ScreenRequestDto;
import com.cibook.bookingticket.dto.ScreenWithLocationDto;
import com.cibook.bookingticket.model.Screen;
import com.cibook.bookingticket.model.Seat;
import com.cibook.bookingticket.model.Screen.ScreenStatus;
import com.cibook.bookingticket.repository.ScreenRepository;
import com.mongodb.client.AggregateIterable;
import com.mongodb.client.MongoCollection;
import lombok.extern.slf4j.Slf4j;
import org.bson.Document;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.webjars.NotFoundException;

import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
public class ScreenService implements IService<Screen, String> {
    private final ScreenRepository screenRepository;
    private final AutoGeneratedCode codeGenerator;
    private final MongoTemplate mongoTemplate;
    private final SeatService seatService;

    @Autowired
    public ScreenService(ScreenRepository screenRepository, AutoGeneratedCode codeGenerator,
            MongoTemplate mongoTemplate, SeatService seatService) {
        this.screenRepository = screenRepository;
        this.codeGenerator = codeGenerator;
        this.mongoTemplate = mongoTemplate;
        this.seatService = seatService;
    }

    @Override
    public Screen add(Screen entity) {
        log.info("Adding new screen");
        entity.setScreenCode(codeGenerator.generateScreenCode(entity.getCinemaCode()));
        return screenRepository.save(entity);
    }

    @Transactional
    public Screen addWithSeats(ScreenRequestDto entity) {
        String screenCode = codeGenerator.generateScreenCode(entity.getCinemaCode());
        Screen screen = mapToScreen(entity, screenCode);
        mapToSeats(entity, screenCode, screen.getCinemaCode());
        return screen;
    }

    @Transactional
    public Screen updateWithSeats(String id, ScreenRequestDto entity) {
        Screen screen = screenRepository.findById(id).orElse(null);
        if (screen == null) {
            return null;
        }
        screen.setCinemaCode(entity.getCinemaCode());
        screen.setRow(entity.getRow());
        screen.setCol(entity.getCol());
        screen.setCapacity(entity.getCapacity());
        screen.setType(entity.getType());
        screen = screenRepository.save(screen);

        seatService.deleteByScreenAndCinema(screen.getCinemaCode(), screen.getScreenCode());
        mapToSeats(entity, screen.getScreenCode(), screen.getCinemaCode());

        return screen;
    }

    private List<Seat> mapToSeats(ScreenRequestDto dto, String screenCode, String cinemaCode) {
        System.out.println(screenCode);
        List<Seat> seats = dto.getSeats().stream()
                .map(seat -> Seat.builder()
                        .cinemaCode(cinemaCode)
                        .screenCode(screenCode)
                        .type(seat.getType())
                        .row(seat.getRow())
                        .seatCode(seat.getId())
                        .number(seat.getId().substring(1))
                        .build())
                .collect(Collectors.toList());
        return seatService.addAll(seats);
    }

    private Screen mapToScreen(ScreenRequestDto dto, String screenCode) {
        Screen screen = Screen.builder()
                .cinemaCode(dto.getCinemaCode())
                .screenCode(screenCode)
                .row(dto.getRow())
                .col(dto.getCol())
                .capacity(dto.getCapacity())
                .type(dto.getType())
                .build();
        return screenRepository.save(screen);
    }

    @Override
    public Optional<Screen> findById(String id) {
        return screenRepository.findById(id);
    }

    @Override
    public Optional<Screen> findByCode(String id) {
        return screenRepository.findByScreenCode(id);
    }

    @Override
    public List<Screen> findAll() {
        return screenRepository.findAll();
    }

    @Override
    public Page<Screen> findAll(Pageable pageable) {
        return screenRepository.findAll(pageable);
    }

    public Page<ScreenWithLocationDto> getScreensWithLocation(Pageable pageable, String cinema, String owner,
            String address, String status) {
        MongoCollection<Document> collection = mongoTemplate.getCollection("screens");
        List<Document> pipeline = new ArrayList<>();
        if (status != null && !status.isEmpty()) {
            pipeline.add(new Document("$match", new Document("status", status)));
        }
        if (owner != null && !owner.isEmpty()) {
            pipeline.add(new Document("$match", new Document("owner", owner)));
        }

        if (cinema != null && !cinema.isEmpty()) {
            pipeline.add(new Document("$match",
                    new Document("cinemaCode", new Document("$regex", ".*" + cinema + ".*").append("options", "i"))));
        }
        pipeline.addAll(Arrays.asList(
                new Document("$lookup",
                        new Document("from", "cinemas")
                                .append("localField", "cinemaCode")
                                .append("foreignField", "cinemaCode")
                                .append("as", "cinema")),
                new Document("$unwind", "$cinema")));
        if (address != null && !address.isEmpty()) {
            pipeline.add(new Document("$match", new Document("$expr",
                    new Document("$regexMatch", new Document()
                            .append("input", new Document("$replaceAll", new Document()
                                    .append("input", "$cinema.location")
                                    .append("find", ".")
                                    .append("replacement", "")))
                            .append("regex", ".*" + address.replace(".", "") + ".*")
                            .append("options", "i")))));

        }
        pipeline.addAll(Arrays.asList(
                new Document("$project",
                        new Document("id", 1L)
                                .append("screenCode", 1L)
                                .append("type", 1L)
                                .append("capacity", 1L)
                                .append("status", 1L)
                                .append("cinemaCode", 1L)
                                .append("col", 1L)
                                .append("owner", 1L)
                                .append("row", 1L)
                                .append("location", "$cinema.location")
                                .append("cinemaName", "$cinema.cinemaName")),
                new Document("$sort",
                        new Document("cinemaName", 1L))));

        List<Document> facetPipeline = new ArrayList<>();
        facetPipeline.add(new Document("$skip", pageable.getOffset()));
        facetPipeline.add(new Document("$limit", pageable.getPageSize()));

        List<Document> countPipeline = new ArrayList<>();
        countPipeline.add(new Document("$count", "total"));

        pipeline.add(new Document("$facet", new Document()
                .append("content", facetPipeline)
                .append("count", countPipeline)));

        AggregateIterable<Document> result = collection.aggregate(pipeline);
        Document resultDoc = result.first();

        List<Document> contentDocs = resultDoc.getList("content", Document.class);
        List<Document> countDocs = resultDoc.getList("count", Document.class);
        long total = countDocs.isEmpty() ? 0 : countDocs.get(0).getInteger("total");

        List<ScreenWithLocationDto> content = new ArrayList<>();
        for (Document doc : contentDocs) {
            ScreenWithLocationDto dto = new ScreenWithLocationDto();
            dto.setId(doc.getObjectId("_id").toHexString());
            dto.setScreenCode(doc.getString("screenCode"));
            dto.setOwner(doc.getString("owner"));
            dto.setType(doc.getString("type"));
            dto.setCapacity(doc.getInteger("capacity"));
            dto.setStatus(doc.getString("status"));
            dto.setRow(doc.getInteger("row"));
            dto.setCol(doc.getInteger("col"));
            dto.setCinemaCode(doc.getString("cinemaCode"));
            dto.setCinemaName(doc.getString("cinemaName"));
            dto.setCinemaLocation(doc.getString("location"));
            content.add(dto);
        }
        return new PageImpl<>(content, pageable, total);
    }

    @Override
    public Map<String, String> findAllNamesWithID() {
        return screenRepository.findAll().stream()
                .filter(screen -> screen.getScreenCode() != null && screen.getCinemaCode() != null).collect(Collectors
                        .toMap(Screen::getCinemaCode, Screen::getScreenCode, (existing, replacement) -> existing));
    }

    public Map<String, List<String>> findAllNamesWithIDs() {
        return screenRepository.findAll().stream()
                .filter(screen -> screen.getScreenCode() != null && screen.getCinemaCode() != null)
                .collect(Collectors.groupingBy(Screen::getCinemaCode,
                        Collectors.mapping(Screen::getScreenCode, Collectors.toList())));
    }

    @Override
    public Screen update(String id, Screen entity) {
        if (!existsById(id))
            return null;
        Screen screen = findById(id).get();
        entity.setScreenCode(screen.getScreenCode());
        entity.setId(screen.getId());
        return screenRepository.save(entity);
    }

    @Override
    public void deleteById(String id) {
        Screen screen = findById(id).get();
        seatService.deleteByScreenAndCinema(screen.getCinemaCode(), screen.getScreenCode());
        screenRepository.deleteById(id);
    }

    @Override
    public boolean existsById(String id) {
        return screenRepository.existsById(id);
    }

    public List<Screen.ScreenType> findAllTypes() {
        return screenRepository.findAllByType().stream().map(Screen::getType).distinct().collect(Collectors.toList())
                .reversed();
    }

    public List<Screen> addMany(List<Screen> entity) {
        entity.forEach(ent -> ent.setScreenCode(codeGenerator.generateScreenCode(ent.getCinemaCode())));
        return screenRepository.saveAll(entity);
    }

    public void deleteAll() {
        screenRepository.deleteAll();
    }

    public int getSeatsById(String screenCode, String cinemaCode) {
        Query query = new Query();
        query.addCriteria(Criteria.where("screenCode").is(screenCode)
                .and("cinemaCode").is(cinemaCode));
        query.fields().include("capacity").exclude("_id");
        Document result = mongoTemplate.findOne(query, Document.class, "screens");
        return result.getInteger("capacity", 0);
    }

    public void updateStatus(String id, String string) {
        Screen screen = findById(id).orElseThrow(() -> new NotFoundException("Screen not found with ID: " + id));
        screen.setStatus(ScreenStatus.valueOf(string));
        screenRepository.save(screen);
    }
}
