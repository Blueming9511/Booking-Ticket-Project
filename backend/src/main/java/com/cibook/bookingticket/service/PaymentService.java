package com.cibook.bookingticket.service;

import com.cibook.bookingticket.dto.CinemaDashboardDto;
import com.cibook.bookingticket.dto.ProductDashboardDto;
import com.cibook.bookingticket.dto.RecentBookingsDto;
import com.cibook.bookingticket.dto.RevenueDTO;
import com.cibook.bookingticket.model.Payment;
import com.cibook.bookingticket.model.Payment.PaymentStatus;
import com.cibook.bookingticket.repository.PaymentRepository;
import lombok.extern.slf4j.Slf4j;

import org.bson.Document;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.Aggregation;
import org.springframework.data.mongodb.core.aggregation.AggregationResults;
import org.springframework.data.mongodb.core.aggregation.GroupOperation;
import org.springframework.data.mongodb.core.aggregation.MatchOperation;
import org.springframework.data.mongodb.core.aggregation.ArrayOperators.In;
import org.springframework.data.mongodb.core.aggregation.ConvertOperators;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Slf4j
@Service
public class PaymentService implements IService<Payment, String> {
    private final PaymentRepository paymentRepository;
    private final AutoGeneratedCode codeGenerator;
    private final MongoTemplate mongoTemplate;

    @Autowired
    public PaymentService(PaymentRepository paymentRepository, AutoGeneratedCode codeGenerator,
            MongoTemplate mongoTemplate) {
        this.paymentRepository = paymentRepository;
        this.codeGenerator = codeGenerator;
        this.mongoTemplate = mongoTemplate;
    }

    @Override
    public Payment add(Payment entity) {
        entity.setPaymentCode(codeGenerator.generatePaymentCode());
        return paymentRepository.save(entity);
    }

    @Override
    public Optional<Payment> findById(String id) {
        return paymentRepository.findById(id);
    }

    @Override
    public Optional<Payment> findByCode(String id) {
        return paymentRepository.findByPaymentCode(id);
    }

    @Override
    public List<Payment> findAll() {
        return paymentRepository.findAll();
    }

    @Override
    public Page<Payment> findAll(Pageable pageable) {
        return paymentRepository.findAll(pageable);
    }

    public Page<Payment> findByOwnerAndStatus(Pageable pageable, String owner, String status, String method,
            LocalDateTime startDate, LocalDateTime endDate, Double maxPrice, Double minPrice) {
        Query query = new Query();
        if (owner != null && !owner.trim().isEmpty()) {
            query.addCriteria(Criteria.where("owner").regex(owner, "i"));
        }
        if (status != null && !status.trim().isEmpty()) {
            query.addCriteria(Criteria.where("status").regex(status, "i"));
        }
        if (method != null && !method.trim().isEmpty()) {
            query.addCriteria(Criteria.where("method").regex(method, "i"));
        }
        if (startDate != null) {
            query.addCriteria(Criteria.where("date").gte(startDate));
        }
        if (endDate != null) {
            query.addCriteria(Criteria.where("endDate").lte(endDate));
        }
        if (maxPrice != null && maxPrice > 0) {
            query.addCriteria(Criteria.where("price").lte(maxPrice));
        }
        if (minPrice != null && minPrice > 0) {
            query.addCriteria(Criteria.where("price").gte(minPrice));
        }
        query.with(pageable);
        query.with(Sort.by("date").descending());
        List<Payment> results = mongoTemplate.find(query, Payment.class);
        long count = mongoTemplate.count(query.skip(-1).limit(-1), Payment.class);

        return new PageImpl<>(results, pageable, count);
    }

    @Override
    public Map<String, String> findAllNamesWithID() {
        return null;
    }

    @Override
    public Payment update(String id, Payment entity) {
        Payment payment = paymentRepository.findById(id).orElse(null);
        entity.setId(id);
        entity.setPaymentCode(payment.getPaymentCode());
        return paymentRepository.save(entity);
    }

    @Override
    public void deleteById(String id) {
        paymentRepository.deleteById(id);
    }

    @Override
    public boolean existsById(String id) {
        return paymentRepository.existsById(id);
    }

    public List<Payment> addAll(List<Payment> payments) {
        payments.stream().forEach(payment -> payment.setPaymentCode(codeGenerator.generatePaymentCode()));
        return paymentRepository.saveAll(payments);
    }

    public void deleteAll() {
        paymentRepository.deleteAll();
    }

    private Double getTotalRevenueApproved() {
        MatchOperation matchStage = Aggregation.match(Criteria.where("status").is("APPROVED"));
        GroupOperation groupStage = Aggregation.group().sum("amount").as("totalRevenue");
        Aggregation aggregation = Aggregation.newAggregation(matchStage, groupStage);
        AggregationResults<Document> result = mongoTemplate.aggregate(aggregation, "payments", Document.class);
        Document doc = result.getUniqueMappedResult();
        return doc != null ? doc.getDouble("totalRevenue") : 0.0;
    }

    private Double getTotalRevenueAMonth(LocalDateTime startMonth, LocalDateTime endMonth) {
        Date startDate = Date.from(startMonth.atZone(ZoneId.systemDefault()).toInstant());
        Date endDate = Date.from(endMonth.atZone(ZoneId.systemDefault()).toInstant());
        MatchOperation matchStage = Aggregation.match(Criteria
                .where("status").is("APPROVED")
                .and("date").gte(startDate).lte(endDate));
        GroupOperation groupStage = Aggregation.group().sum("amount").as("totalRevenue");
        Aggregation aggregation = Aggregation.newAggregation(matchStage, groupStage);
        AggregationResults<Document> result = mongoTemplate.aggregate(aggregation, "payments", Document.class);
        Document doc = result.getUniqueMappedResult();

        return doc != null ? doc.getDouble("totalRevenue") : 0.0;
    }

    public Map<String, Double> getRevenueStatAMonth() {
        LocalDateTime now = LocalDateTime.now();
        return Map.of(
                "total", getTotalRevenueApproved(),
                "thisMonth", getTotalRevenueAMonth(now.withDayOfMonth(1), now),
                "lastMonth", getTotalRevenueAMonth(now.withDayOfMonth(1).minusMonths(1), now.minusMonths(1)));
    }

    private int getTotalConversionByMonth(LocalDateTime startMonth, LocalDateTime endMonth, PaymentStatus status) {
        Query query = new Query();

        if (startMonth != null && endMonth != null) {
            query.addCriteria(
                    Criteria.where("date").gte(Date.from(startMonth.atZone(ZoneId.systemDefault()).toInstant()))
                            .lte(Date.from(endMonth.atZone(ZoneId.systemDefault()).toInstant())));
        } else if (startMonth != null) {
            query.addCriteria(
                    Criteria.where("date").gte(Date.from(startMonth.atZone(ZoneId.systemDefault()).toInstant())));
        } else if (endMonth != null) {
            query.addCriteria(
                    Criteria.where("date").lte(Date.from(endMonth.atZone(ZoneId.systemDefault()).toInstant())));
        }

        if (status != null) {
            query.addCriteria(Criteria.where("status").is(status));
        }

        return (int) mongoTemplate.count(query, "payments");
    }

    public Map<String, Double> getConversionRate() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime thisMonth = now.withDayOfMonth(1);
        LocalDateTime lastMonthStart = now.withDayOfMonth(1).minusMonths(1);
        LocalDateTime lastMonthEnd = thisMonth.minusSeconds(1);

        long thisMonthTotal = getTotalConversionByMonth(thisMonth, now, null);
        long thisMonthApproved = getTotalConversionByMonth(thisMonth, now, PaymentStatus.APPROVED);
        double thisMonthRate = thisMonthTotal == 0 ? 0.0 : (double) thisMonthApproved / thisMonthTotal;

        long lastMonthTotal = getTotalConversionByMonth(lastMonthStart, lastMonthEnd, null);
        long lastMonthApproved = getTotalConversionByMonth(lastMonthStart, lastMonthEnd, PaymentStatus.APPROVED);
        double lastMonthRate = lastMonthTotal == 0 ? 0.0 : (double) lastMonthApproved / lastMonthTotal;

        long total = getTotalConversionByMonth(null, null, null);
        long totalApproved = getTotalConversionByMonth(null, null, PaymentStatus.APPROVED);
        double totalRate = total == 0 ? 0.0 : (double) totalApproved / total;

        return Map.of(
                "thisMonth", thisMonthRate,
                "lastMonth", lastMonthRate,
                "total", totalRate);
    }

    public List<RevenueDTO> getRevenueByMonth() {
        Aggregation aggregation = Aggregation.newAggregation(
                Aggregation.match(Criteria.where("status").is(PaymentStatus.APPROVED)),
                Aggregation.project()
                        .and("amount").as("revenue")
                        .and("date").as("date"),
                Aggregation.project()
                        .and("revenue").as("revenue")
                        .andExpression("dateToString('%Y-%m', date)").as("period"),
                Aggregation.group("period")
                        .sum("revenue").as("revenue")
                        .count().as("orders"),
                Aggregation.project()
                        .and("_id").as("period")
                        .and("revenue").as("revenue")
                        .and("orders").as("orders"),
                Aggregation.sort(Sort.by(Sort.Direction.ASC, "period")));
        return mongoTemplate.aggregate(aggregation, "payments", RevenueDTO.class).getMappedResults();
    }

    public List<RevenueDTO> getRevenueByQuarter() {
        Aggregation aggregation = Aggregation.newAggregation(
                Aggregation.match(Criteria.where("status").is(PaymentStatus.APPROVED)),
                Aggregation.project()
                        .and("amount").as("revenue")
                        .and("date").as("date"),
                Aggregation.project()
                        .and("revenue").as("revenue")
                        .andExpression("concat('Q', toString(ceil(month(date) / 3.0)), ' ', toString(year(date)))")
                        .as("period"),
                Aggregation.group("period")
                        .sum("revenue").as("revenue")
                        .count().as("orders"),
                Aggregation.project()
                        .and("_id").as("period")
                        .and("revenue").as("revenue")
                        .and("orders").as("orders"),
                Aggregation.sort(Sort.by(Sort.Direction.ASC, "period")));

        return mongoTemplate.aggregate(aggregation, "payments", RevenueDTO.class).getMappedResults();
    }

    public List<RevenueDTO> getRevenueByWeek() {
        Aggregation aggregation = Aggregation.newAggregation(
                Aggregation.match(Criteria.where("status").is(PaymentStatus.APPROVED)),
                Aggregation.project()
                        .and("amount").as("revenue")
                        .and("date").as("date"),
                Aggregation.project()
                        .and("revenue").as("revenue")
                        .andExpression("concat('Week ', toString(week(date)), ' ', toString(year(date)))").as("period"),
                Aggregation.group("period")
                        .sum("revenue").as("revenue")
                        .count().as("orders"),
                Aggregation.project()
                        .and("_id").as("period")
                        .and("revenue").as("revenue")
                        .and("orders").as("orders"),
                Aggregation.sort(Sort.by(Sort.Direction.ASC, "_id")));

        return mongoTemplate.aggregate(aggregation, "payments", RevenueDTO.class).getMappedResults();
    }

    public List<RevenueDTO> getRevenueByYear() {
        Aggregation aggregation = Aggregation.newAggregation(
                Aggregation.match(Criteria.where("status").is(PaymentStatus.APPROVED)),
                Aggregation.project()
                        .and("amount").as("revenue")
                        .andExpression("year(date)").as("period"),
                Aggregation.group("period")
                        .sum("revenue").as("revenue")
                        .count().as("orders"),
                Aggregation.project()
                        .and("_id").as("period")
                        .and("revenue").as("revenue")
                        .and("orders").as("orders"),
                Aggregation.sort(Sort.by(Sort.Direction.ASC, "_id")));

        return mongoTemplate.aggregate(aggregation, "payments", RevenueDTO.class).getMappedResults();
    }

    public List<ProductDashboardDto> getProductDashboardData() {
        Aggregation aggregation = Aggregation.newAggregation(
                Aggregation.match(Criteria.where("status").is(PaymentStatus.APPROVED)),

                Aggregation.addFields()
                        .addField("convertedBookingId")
                        .withValue(ConvertOperators.ToObjectId.toObjectId("$bookingID"))
                        .build(),

                Aggregation.lookup("bookings", "convertedBookingId", "_id", "booking"),
                Aggregation.unwind("booking"),

                Aggregation.lookup("showtimes", "booking.showTimeCode", "showTimeCode", "showtime"),
                Aggregation.unwind("showtime"),

                Aggregation.lookup("movies", "showtime.movieCode", "movieCode", "movie"),
                Aggregation.unwind("movie"),

                Aggregation.group("movie.title")
                        .sum("amount").as("revenue")
                        .count().as("sales"),

                Aggregation.project()
                        .and("_id").as("title")
                        .and("revenue").as("revenue")
                        .and("sales").as("sales"),

                Aggregation.limit(5),
                Aggregation.sort(Sort.by(Sort.Direction.DESC, "revenue")));

        return mongoTemplate.aggregate(aggregation, "payments", ProductDashboardDto.class).getMappedResults();
    }

    public List<CinemaDashboardDto> getTopCinemas() {
        Aggregation aggregation = Aggregation.newAggregation(
                Aggregation.match(Criteria.where("status").is(PaymentStatus.APPROVED)),

                Aggregation.addFields()
                        .addField("convertedBookingId")
                        .withValue(ConvertOperators.ToObjectId.toObjectId("$bookingID"))
                        .build(),

                Aggregation.lookup("bookings", "convertedBookingId", "_id", "booking"),
                Aggregation.unwind("booking"),

                Aggregation.lookup("showtimes", "booking.showTimeCode", "showTimeCode", "showtime"),
                Aggregation.unwind("showtime"),

                Aggregation.lookup("cinemas", "showtime.cinemaCode", "cinemaCode", "cinema"),
                Aggregation.unwind("cinema"),

                Aggregation.group("cinema.cinemaName")
                        .sum("amount").as("revenue"),

                Aggregation.project()
                        .and("_id").as("cinemaName")
                        .and("revenue").as("revenue"),

                Aggregation.sort(Sort.by(Sort.Direction.DESC, "revenue")),
                Aggregation.limit(5));

        return mongoTemplate.aggregate(aggregation, "payments",
                CinemaDashboardDto.class).getMappedResults();
    }

    public List<RecentBookingsDto> getRecentBookings() {
        Aggregation aggregation = Aggregation.newAggregation(

                Aggregation.addFields()
                        .addField("convertedBookingId")
                        .withValue(ConvertOperators.ToObjectId.toObjectId("$bookingID"))
                        .build(),

                Aggregation.lookup("bookings", "convertedBookingId", "_id", "booking"),
                Aggregation.unwind("booking", true),

                Aggregation.lookup("showtimes", "booking.showTimeCode", "showTimeCode", "showtime"),
                Aggregation.unwind("showtime", true),

                Aggregation.lookup("movies", "showtime.movieCode", "movieCode", "movie"),
                Aggregation.unwind("movie", true),

                Aggregation.addFields()
                        .addField("userIdObj")
                        .withValue(ConvertOperators.ToObjectId.toObjectId("$booking.userId"))
                        .build(),

                Aggregation.lookup("users", "userIdObj", "_id", "user"),
                Aggregation.unwind("user", true),

                Aggregation.sort(Sort.by(Sort.Direction.DESC, "date")),
                Aggregation.limit(5),

                Aggregation.project()
                        .and("movie.title").as("movieTitle")
                        .and("user.name").as("customerName")
                        .and("amount").as("totalAmount")
                        .andExpression("dateToString('%Y-%m-%d %H:%M:%S', date)").as("bookingDate")
                        .and("status").as("status")
                        .and("owner").as("owner")
                        .andExclude("_id"));

        return mongoTemplate.aggregate(aggregation, "payments",
                RecentBookingsDto.class).getMappedResults();
    }
}
