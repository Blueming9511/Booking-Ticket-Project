package com.cibook.bookingticket.service;

import com.cibook.bookingticket.dto.ShowtimeResponseDto;
import com.cibook.bookingticket.model.Showtime;
import com.cibook.bookingticket.model.Showtime.ShowTimeStatus;
import com.cibook.bookingticket.repository.ShowtimeRepository;
import com.cibook.bookingticket.util.BeanUtilHelper;
import com.mongodb.client.AggregateIterable;
import com.mongodb.client.MongoCollection;
import org.bson.Document;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Service;
import org.webjars.NotFoundException;

import java.text.ParseException;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;

@Service
public class ShowtimeService implements IService<Showtime, String> {

    private final ScreenService screenService;
    private final ShowtimeRepository showtimeRepository;
    private final AutoGeneratedCode codeGenerator;
    private final MongoTemplate mongoTemplate;

    public ShowtimeService(ShowtimeRepository showtimeRepository, AutoGeneratedCode codeGenerator,
            MongoTemplate mongoTemplate, ScreenService screenService) {
        this.showtimeRepository = showtimeRepository;
        this.codeGenerator = codeGenerator;
        this.mongoTemplate = mongoTemplate;
        this.screenService = screenService;
    }

    @Override
    public Showtime add(Showtime entity) {
        entity.setShowTimeCode(codeGenerator.generateShowtimeCode());
        entity.setSeats(screenService.getSeatsById(entity.getScreenCode(), entity.getCinemaCode()));
        entity.setBookedSeats(0);
        entity.setStatus(ShowTimeStatus.AVAILABLE);
        System.out.println(entity);
        return showtimeRepository.save(entity);
    }

    @Override
    public Optional<Showtime> findById(String id) {
        return showtimeRepository.findById(id);
    }

    @Override
    public Optional<Showtime> findByCode(String id) {
        return showtimeRepository.findByShowTimeCode(id);
    }

    @Override
    public List<Showtime> findAll() {
        return showtimeRepository.findAll();
    }

    @Override
    public Page<Showtime> findAll(Pageable pageable) {
        return showtimeRepository.findAll(pageable);
    }

    public Page<ShowtimeResponseDto> findAllShowtimes(Pageable pageable, String owner, String movie, String status,
            String address, LocalDateTime startTime, LocalDateTime endTime, String type, String cinemaCode)
            throws ParseException {

        MongoCollection<Document> collection = mongoTemplate.getCollection("showtimes");

        List<Document> pipeline = new ArrayList<>();

        Document matchStage = new Document();
        if (status != null && !status.isEmpty()) {
            matchStage.append("status", status);
        }

        if (cinemaCode != null && !cinemaCode.isEmpty()) {
            matchStage.append("cinemaCode", cinemaCode);
        }

        if (owner != null && !owner.isEmpty()) {
            matchStage.append("owner", owner);
        }
        if (type != null && !type.isEmpty()) {
            matchStage.append("type", type);
        }
        if (startTime != null || endTime != null) {
            Document timeFilter = new Document();
            if (startTime != null) {
                timeFilter.append("$gte", Date.from(startTime.atZone(ZoneId.systemDefault()).toInstant()));
            }
            if (endTime != null) {
                timeFilter.append("$lte", Date.from(endTime.atZone(ZoneId.systemDefault()).toInstant()));
            }
            matchStage.append("startTime", timeFilter);
        }
        if (!matchStage.isEmpty()) {
            pipeline.add(new Document("$match", matchStage));
        }

        pipeline.add(new Document("$lookup",
                new Document("from", "cinemas")
                        .append("let", new Document("cinemaCode", "$cinemaCode"))
                        .append("pipeline", Arrays.asList(
                                new Document("$match",
                                        new Document("$expr",
                                                new Document("$eq", Arrays.asList("$cinemaCode", "$$cinemaCode")))),
                                new Document("$project",
                                        new Document("location", 1L).append("_id", 0L))))
                        .append("as", "cinema")));

        List<Document> movieLookupPipeline = new ArrayList<>();
        movieLookupPipeline.add(new Document("$match",
                new Document("$expr", new Document("$eq", Arrays.asList("$movieCode", "$$movieCode")))));

        if (movie != null && !movie.trim().isEmpty()) {
            movieLookupPipeline.add(new Document("$match", new Document("title",
                    new Document("$regex", movie).append("$options", "i"))));
        }

        movieLookupPipeline.add(new Document("$project", new Document("name", 1L)
                .append("rating", 1L)
                .append("duration", 1L)
                .append("thumbnail", 1L)
                .append("title", 1L)
                .append("_id", 0L)));

        pipeline.add(new Document("$lookup",
                new Document("from", "movies")
                        .append("let", new Document("movieCode", "$movieCode"))
                        .append("pipeline", movieLookupPipeline)
                        .append("as", "movie")));

        pipeline.add(new Document("$unwind", "$cinema"));
        pipeline.add(new Document("$unwind", "$movie"));

        if (address != null && !address.trim().isEmpty()) {
            pipeline.add(new Document("$match", new Document("cinema.location",
                    new Document("$regex", address).append("$options", "i"))));
        }

        pipeline.add(new Document("$project", new Document()
                .append("_id", 1L)
                .append("cinemaCode", 1L)
                .append("screenCode", 1L)
                .append("status", 1L)
                .append("movieCode", 1L)
                .append("seats", 1L)
                .append("bookedSeats", 1L)
                .append("startTime", 1L)
                .append("endTime", 1L)
                .append("price", 1L)
                .append("showTimeCode", 1L)
                .append("owner", 1L)
                .append("type", 1L)
                .append("data", 1L)
                .append("movieName", "$movie.name")
                .append("movieThumbnail", "$movie.thumbnail")
                .append("movieRating", "$movie.rating")
                .append("movieTitle", "$movie.title")
                .append("movieDuration", "$movie.duration")
                .append("cinemaLocation", "$cinema.location")));

        List<Document> facetPipeline = new ArrayList<>();
        facetPipeline.add(new Document("$skip", pageable.getOffset()));
        facetPipeline.add(new Document("$limit", pageable.getPageSize()));

        List<Document> countPipeline = new ArrayList<>();
        countPipeline.add(new Document("$count", "total"));

        pipeline.add(new Document("$facet", new Document()
                .append("content", facetPipeline)
                .append("count", countPipeline)));

        AggregateIterable<Document> result = collection.aggregate(pipeline);
        Document resultDoc = result.first();
        if (resultDoc == null) {
            return new PageImpl<>(Collections.emptyList(), pageable, 0);
        }

        List<Document> contentDocs = resultDoc.getList("content", Document.class);
        List<Document> countDocs = resultDoc.getList("count", Document.class);
        long total = countDocs.isEmpty() ? 0 : countDocs.get(0).getInteger("total");

        List<ShowtimeResponseDto> showtimes = new ArrayList<>();
        for (Document doc : contentDocs) {
            ShowtimeResponseDto dto = ShowtimeResponseDto.builder()
                    .id(doc.getObjectId("_id").toHexString())
                    .cinemaCode(doc.getString("cinemaCode"))
                    .screenCode(doc.getString("screenCode"))
                    .status(Showtime.ShowTimeStatus.valueOf(doc.getString("status")))
                    .movieCode(doc.getString("movieCode"))
                    .seats(doc.getInteger("seats"))
                    .bookedSeats(doc.getInteger("bookedSeats"))
                    .startTime(doc.getDate("startTime"))
                    .endTime(doc.getDate("endTime"))
                    .price(doc.getDouble("price"))
                    .showTimeCode(doc.getString("showTimeCode"))
                    .movieTitle(doc.getString("movieTitle"))
                    .movieRating(doc.getDouble("movieRating"))
                    .movieThumbnail(doc.getString("movieThumbnail"))
                    .movieDuration(doc.getInteger("movieDuration"))
                    .cinemaLocation(doc.getString("cinemaLocation"))
                    .owner(doc.getString("owner"))
                    .build();
            showtimes.add(dto);
        }

        return new PageImpl<>(showtimes, pageable, total);
    }

    @Override
    public Map<String, String> findAllNamesWithID() {
        return null;
    }

    @Override
    public Showtime update(String id, Showtime entity) {
        if (!existsById(id))
            return null;
        Showtime showtime = showtimeRepository.findById(id).get();
        entity.setId(id);
        entity.setShowTimeCode(showtime.getShowTimeCode());
        if (entity.getScreenCode() != null) {
            entity.setSeats(screenService.getSeatsById(entity.getScreenCode(), entity.getCinemaCode()));
        }
        BeanUtilHelper.copyNonNullProperties(entity, showtime);
        return showtimeRepository.save(showtime);
    }

    @Override
    public void deleteById(String id) {
        showtimeRepository.deleteById(id);
    }

    @Override
    public boolean existsById(String id) {
        return showtimeRepository.existsById(id);
    }

    public Page<Showtime> findAllWithOwner(Pageable pageable, String owner) {
        if (owner.isEmpty())
            return showtimeRepository.findAll(pageable);
        return showtimeRepository.findByOwner(owner, pageable);
    }

    public void updateStatus(String id, String status) {
        Showtime showtime = findById(id).orElseThrow(() -> new NotFoundException("Showtime not found with ID: " + id));
        showtime.setStatus(ShowTimeStatus.valueOf(status));
        showtimeRepository.save(showtime);
    }

    public List<Showtime> findByCinemaId(String id) {
        return showtimeRepository.findByCinemaCode(id);
    }
}
