package com.cibook.bookingticket.service;

import com.cibook.bookingticket.model.Cinema;
import com.cibook.bookingticket.model.Screen;
import com.cibook.bookingticket.model.Seat;
import com.cibook.bookingticket.repository.CinemaRepository;
import com.cibook.bookingticket.repository.ScreenRepository;
import com.cibook.bookingticket.repository.SeatRepository;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class SeatService implements IService<Seat, String> {
    private final SeatRepository seatRepository;
    private final AutoGeneratedCode codeGenerator;
    private final ScreenRepository screenRepository;
    private final CinemaRepository cinemaRepository;

    private static final Logger log = LoggerFactory.getLogger(SeatService.class);

    @Autowired
    public SeatService(SeatRepository seatRepository, AutoGeneratedCode codeGenerator,
            ScreenRepository screenRepository, CinemaRepository cinemaRepository) {
        this.seatRepository = seatRepository;

        this.codeGenerator = codeGenerator;
        this.screenRepository = screenRepository;
        this.cinemaRepository = cinemaRepository;
    }

    @Override
    public Seat add(Seat entity) {
        entity.setSeatCode(
                codeGenerator.generateSeatCode(entity.getScreenCode(), entity.getCinemaCode(), entity.getRow()));
        return seatRepository.save(entity);
    }

    @Override
    public Optional<Seat> findById(String id) {
        return seatRepository.findById(id);
    }

    @Override
    public Optional<Seat> findByCode(String id) {
        return seatRepository.findBySeatCode(id);
    }

    @Override
    public List<Seat> findAll() {
        return seatRepository.findAll();
    }

    @Override
    public Map<String, String> findAllNamesWithID() {
        return null;
    }

    @Override
    public Seat update(String id, Seat entity) {
        if (!existsById(id))
            return null;
        Seat seat = seatRepository.findById(id).get();
        entity.setSeatCode(seat.getSeatCode());
        entity.setId(seat.getId());
        return seatRepository.save(entity);
    }

    @Override
    public void deleteById(String id) {
        seatRepository.deleteById(id);
    }

    @Override
    public boolean existsById(String id) {
        return seatRepository.existsById(id);
    }

    public List<Seat> addAll(List<Seat> seats) {
        seats.forEach(seat -> seat.setSeatCode(
                codeGenerator.generateSeatCode(seat.getScreenCode(), seat.getCinemaCode(), seat.getRow())));
        return seatRepository.saveAll(seats);
    }

    public void deleteAll() {
        seatRepository.deleteAll();
    }

    // Generate seats
    @Transactional
    public List<Seat> defineAndGenerateSeatsForCinema(String cinemaCode, String screenCode, ScreenLayoutDefinition layoutDef) {
        log.info("Defining layout for Cinema: {}, Screen: {}", cinemaCode, screenCode);

        // --- 1. Validation ---
         if (layoutDef == null || layoutDef.getTotalRows() <= 0 || layoutDef.getTotalColumns() <= 0) {
             log.error("Invalid layout definition provided for cinemaCode: {}, screenCode: {}", cinemaCode, screenCode);
             throw new IllegalArgumentException("Layout definition must include positive rows and columns.");
         }

        // Validate that the specific Cinema/Screen combination exists
        // Assuming Screen model has both cinemaCode and screenCode fields
        Screen screen = screenRepository.findByCinemaIdAndScreenCode(cinemaCode, screenCode) // <-- Find by COMBINATION
                .orElseThrow(() -> {
                    log.error("Screen with code {} not found within cinema {}.", screenCode, cinemaCode);
                    return new NoSuchElementException("Screen " + screenCode + " not found in Cinema " + cinemaCode);
                });

    // --- 2. Clear Existing Seats for this SPECIFIC Cinema/Screen combination ---
    log.info("Deleting existing seats for cinemaCode: {}, screenCode: {}", cinemaCode, screenCode);
    // *** IMPORTANT: Update Repository Method ***
    // You need a method to delete seats matching BOTH cinemaCode and screenCode.
    long deleteCount = seatRepository.deleteByCinemaCodeAndScreenCode(cinemaCode, screenCode); // <-- CHANGE THIS METHOD
    log.info("Deleted {} existing seats for cinemaCode: {}, screenCode: {}", deleteCount, cinemaCode, screenCode);

    // --- 3. Prepare Generation Data ---
    List<Seat> generatedSeats = new ArrayList<>();
    Set<String> unavailableSet = layoutDef.getUnavailableSeatNumbers() != null
            ? layoutDef.getUnavailableSeatNumbers()
            : Collections.emptySet();
    Set<String> coupleSeatOccupied = new HashSet<>();

  


    // --- 5. Generate Standard/VIP/COUPLE Seats ---
    for (int r = 0; r < layoutDef.getTotalRows(); r++) {
        String rowLetter = String.valueOf((char) ('A' + r));
        for (int c = 1; c <= layoutDef.getTotalColumns(); c++) {
            String seatNumberLabel = String.format("%s%02d", rowLetter, c);

            if (unavailableSet.contains(seatNumberLabel) || coupleSeatOccupied.contains(seatNumberLabel)) {
                log.trace("Skipping seat: {}", seatNumberLabel);
                continue;
            }

            Seat.SeatType currentSeatType = findSeatTypeFromZones(rowLetter, c, layoutDef.getSeatTypeZones());
            Double currentMultiplier = getMultiplierForType(currentSeatType);

            Seat seat = new Seat();
            seat.setScreenCode(screenCode);  
            seat.setCinemaCode(cinemaCode);   
            seat.setRow(rowLetter);
            seat.setNumber(String.valueOf(c));
            seat.setType(currentSeatType);
            seat.setMultiplier(currentMultiplier);
            seat.setStatus(Seat.SeatStatus.AVAILABLE);
            seat.setSeatCode(seatNumberLabel);

            generatedSeats.add(seat);
            log.trace("Generated seat: {}", seat.getSeatCode());
        }
    }

    // --- 6. Bulk Save ---
    if (!generatedSeats.isEmpty()) {
        log.info("Saving {} generated seats for cinemaCode: {}, screenCode: {}", generatedSeats.size(), cinemaCode, screenCode);
        return seatRepository.saveAll(generatedSeats);
    } else {
        log.warn("No seats were generated for cinemaCode: {}, screenCode: {}", cinemaCode, screenCode);
        return Collections.emptyList();
    }
} // --- End of defineAndGenerateSeatsForCinema ---

    // --- Helper to determine seat type from zones ---
    private Seat.SeatType findSeatTypeFromZones(String rowLetter, int columnNumber,
            List<ScreenLayoutDefinition.SeatTypeZone> zones) {
        // ... (implementation remains the same) ...
        if (zones != null) {
            for (ScreenLayoutDefinition.SeatTypeZone zone : zones) {
                if (zone.getRows() != null && zone.getRows().stream().anyMatch(r -> r.equalsIgnoreCase(rowLetter))) {
                    // Add column checks here if zones define column ranges
                    return zone.getType();
                }
            }
        }
        return Seat.SeatType.STANDARD; // Default
    }

    // --- Helper to get default multiplier ---
    private Double getMultiplierForType(Seat.SeatType type) {
        // ... (implementation remains the same) ...
        switch (type) {
            case VIP:
                return 1.5;
            case COUPLE:
                return 1.8; 
            case STANDARD:
            default:
                return 1.0;
        }
    }

    public List<Seat> findByCinemaCodeAndScreenCode(String cinemaCode, String screenCode) {
        log.debug("Finding seats for cinemaCode: {} and screenCode: {}", cinemaCode, screenCode);

        // Optional but recommended: Validate that the cinema and screen actually exist first
        // This prevents querying seats for non-existent parent entities.
        if (!cinemaRepository.existsByCinemaCode(cinemaCode)) { // Assumes existsByCinemaCode exists
             throw new NoSuchElementException("Cinema not found with code: " + cinemaCode);
        }
         if (!screenRepository.existsByScreenCodeAndCinemaId(screenCode, cinemaCode)) { // Assumes compound check exists
             throw new NoSuchElementException("Screen " + screenCode + " not found within cinema " + cinemaCode);
         }

        // Fetch seats matching both criteria
        // Assumes findByCinemaCodeAndScreenCode method exists in SeatRepository
        return seatRepository.findByCinemaCodeAndScreenCode(cinemaCode, screenCode);
    }

}
